### __Learn to shape a thinking of the design-patterns__  
#### 1. _The Strategy pattern(策略模式)_  
>策略模式 -- 定义一系列算法封装，讲算法的使用和算法的实现分离出来，并切使它们可以相互替换  
>_条条大路通罗马_，同样，在现实中，很多时候也有多种途径到达同一个目的地，比如我们去一个地方旅游的话可以选择飞机、动车或者自驾游的交通方式。  
>一个基于策略模式的程序至少由两部分组成。第一部分是策略类(Strategy)，它负责具体的算法，负责具体的计算过程；第二部分是环境类(Context)，环境类接受客户的一个请求，并把请求委托给一个策略类。所有Context类中会维持某个对象的引用。

#### 2. _The Observer pattern(观察者模式)_  
>观察者模式 -- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知  
>在JavaScript中观察者模式是用事件模型来实现的，观察者模式广泛应用于异步编程中，这是一种替代传统回调函数的解决方案，比如我们可以订阅ajax请求的error，success事件。使用观察者模式，我们就无需关注对象在异步运行期间的状态，而只需要订阅感兴趣的事件发生点。  
>使用观察者模式可以取代对象之间硬编码的通知机制，一个对象不再显式调用另一个对象的接口，对象之间松散耦合，只要维持之间约定的事件名，发布者和订阅者的内部改变就完全是独立、互不影响的。  

#### 3. _The Flyweight pattern(享元模式)_  
>享元模式 -- 运用共享技术来有效支持大量细粒度的对象  
>一种用于性能优化的模式，_fly_ 是 _苍蝇_ 的意思，意为蝇量级,如果系统中因为很常见了大量类似的对象而导致内存占用过高，享元模式就非常有用了。  
>假如有一个内衣工厂，生产了50种男款内衣和50女款内衣，每种内衣需要模特人穿上照相，一般的处理就会需要50+50个模特，如果提炼出相似点的话就只需要2个模特，男模特和女模特。  
>享元模式要求将对象的属性划分为内部状态和外部状态，目的是为了尽量减少共享对象的数量。内部状态存储与对象内部，可以被一些对象共享，它独立与具体的场景，通常不会改变；外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。最终内部状态相同的对象都指定为同一个共享对象，而外部对象可以从对象身上剥离开来存储在外部。  

#### 4. _The Decorator pattern(装饰者模式)_  
>装饰者模式 -- 动态地为某个对象添加一些额外的职责  
>在程序开发中我们许多时候都不希望某个类天生就非常庞大，一次性地包含许多职责，那个我们就可以使用装饰者模式，动态地为某个对象添加一些额外的职责，而不会影响从这个类派生的其它对象。  
>传统面向对象语言中需要将要包装的操作封装成类，每个类的构造函数都接受一个被包装对象，被包装对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口，当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。  

#### 5. _The Proxy pattern(代理模式)_  
>代理模式 -- 代理模式是为一个对象提供一个待用品或占位符，以便控制对它的访问  
>代理模式是一种非常有意义的模式，生活中有很多使用代理模式的场景：比如明星都是用经纪人作为代理，如果想请明星开演唱会就得联系其经纪人来进行相关安排。  
>代理模式的关键时当客户不方便直接访问一个对象或是不满足需要的时候，提供一个替身对象来控制对对象的访问，客户实际上访问的是替身对象，替身对象对请求做出一些处理后再把请求转交给本体对象。  

#### 6. _The state pattern(状态模式)_
>状态模式 -- 当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。  
>状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况，把状态的判断逻辑转移到不同状态的一系列类中，可以把复杂的判断逻辑简化。主要是为了解决允许一个对象在其内部状态改变时改变它的行为。  
>适用场景:一个对象的行为取决于它的状态，并且必须在运行时根据 状态改变它的行为；一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态。  

#### 7. _The responsibility chain pattern(责任链模式)_
>责任链模式 -- 使多个对象有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理请求为止。  
>责任链模式最大的优点: 请求发送者只需要直到链中的第一个节点，从而弱化了发送者和一组接受者之间的联系。  

#### 8. _The template pattern(模板方法模式)_
> 模板方法模式 -- 一种基于继承的设计模式，模板方法模式由两部分组成，第一部分时抽象父类，第二部分时具体的实现字类，通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及凤爪国内子类中i所有方法的执行顺序，子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。  
> 在模板方法模式中，子类实现中相同部分被上移到父类中，而将不同的部分等待子类来实现，体现了泛化的思想。  
